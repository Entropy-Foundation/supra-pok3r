use async_std::task;
use clap::Parser;
use futures::channel::mpsc;
use num_bigint::BigUint;
use std::thread;

use pok3r::address_book::parse_addr_book_from_json;
use pok3r::common::{EvalNetMsg, DECK_SIZE, PERM_SIZE};
use pok3r::evaluator::Evaluator;
use pok3r::shuffler::{
    compute_decryption_cache, compute_decryption_key, compute_keyper_keys, compute_params,
    compute_permutation_argument, decrypt_one_card, encrypt_and_prove, shuffle_deck,
    verify_encryption_argument, verify_permutation_argument,
};

/// Simple program to greet a person
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Name of the person to greet
    #[arg(short, long)]
    id: String,

    /// Fixed value to generate deterministic peer id
    #[clap(long)]
    seed: u8,

    /// number of parties doing the mpc
    #[clap(long)]
    parties: u64,
}

#[async_std::main]
async fn main() {
    let args = Args::parse();

    //these channels will connect the evaluator and the network daemons
    let (mut n2e_tx, n2e_rx) = mpsc::unbounded::<EvalNetMsg>();
    let (e2n_tx, e2n_rx) = mpsc::unbounded::<EvalNetMsg>();

    let netd_handle = thread::spawn(move || {
        let result = task::block_on(pok3r::network::run_networking_daemon(
            args.seed,
            &parse_addr_book_from_json(args.parties),
            &mut n2e_tx,
            e2n_rx,
        ));
        if let Err(err) = result {
            eprint!("Networking error {:?}", err);
        }
    });

    let addr_book = parse_addr_book_from_json(args.parties);
    let messaging = pok3r::network::MessagingSystem::new(&args.id, addr_book, e2n_tx, n2e_rx).await;
    let mut mpc = Evaluator::new(messaging).await;

    //this is a hack until we figure out
    task::block_on(async {
        task::sleep(std::time::Duration::from_secs(1)).await;
        println!("After sleeping for 1 second.");
    });

    // KZG setup runs once
    let pp = compute_params();

    // Get a random public key pk in G2 - for testing (should be generated by DKG)
    // FIXME: Implement DKG to generate the public key
    let (msk, mpk) = compute_keyper_keys();

    // Actual protocol
    let card_share_handles = shuffle_deck(&mut mpc).await;
    println!("Generated a deck of {} cards", card_share_handles.len());

    let (perm_proof, alpha1) =
        compute_permutation_argument(&pp, &mut mpc, &card_share_handles).await;

    // Get random ids as byte strings
    let ids = (0..PERM_SIZE)
        .map(|i| BigUint::from(i as u64))
        .collect::<Vec<BigUint>>();

    // Encrypt and prove
    let (ctxt, encryption_proof) = encrypt_and_prove(
        &pp,
        &mut mpc,
        card_share_handles.clone(),
        perm_proof.f_com,
        alpha1,
        mpk,
        ids.clone(),
    )
    .await;

    // decrypt all cards
    let cache = compute_decryption_cache();
    let mut decrypted_cards = Vec::new();
    for i in 0..PERM_SIZE {
        let dec_key = compute_decryption_key(&ids[i], msk);

        // ignore the first (PERM_SIZE - DECK_SIZE) cards, which are not part of deck
        if i >= (PERM_SIZE - DECK_SIZE) {
            let card = decrypt_one_card(i, &dec_key, &ctxt, &cache).unwrap();
            decrypted_cards.push(card);
            print!("{},", card);
        }
    }

    assert!(
        verify_permutation_argument(&pp, &perm_proof),
        "Permutation argument verification failed"
    );
    assert!(
        verify_encryption_argument(&pp, &ctxt, &encryption_proof),
        "Encryption proof verification failed"
    );

    // we can verify the proof, but let's also do a sanity check
    // check that decrypted cards is a permutation of 0..51
    let mut sorted_cards = decrypted_cards.clone();
    sorted_cards.sort_unstable();
    let expected_cards: Vec<usize> = (0..DECK_SIZE).collect();
    assert_eq!(
        sorted_cards, expected_cards,
        "Decrypted cards are not a valid permutation of 0..51"
    );
    println!("\ncompleted.");

    netd_handle.join().unwrap();
}
